import{_ as n,o as a,c as s,a as e}from"./app-03ffc0c7.js";const l="/blog/image-20230320131122988.png",i="/blog/image-20230320153854122.png",p={},t=e(`<p>前言：成熟的工具，重点在于配置和使用，原理并不高优；webpack5主要是内部效率的优化，配置上没有太多改动</p><h2 id="基本配置" tabindex="-1"><a class="header-anchor" href="#基本配置" aria-hidden="true">#</a> 基本配置</h2><ul><li>拆分配置和merge <ul><li>使用webpack-merge引用common（通用）配置，不必重复编写重复代码</li></ul></li><li>本地服务 dev-server <ul><li>可配置proxy代理</li></ul></li><li>处理es6 <ul><li>在module/rules里配置babel-loader</li></ul></li><li>处理样式</li><li>处理图片</li><li>模块化</li></ul><h2 id="高级配置" tabindex="-1"><a class="header-anchor" href="#高级配置" aria-hidden="true">#</a> 高级配置</h2><ul><li>多入口 <ul><li>entry里写多个入口，output使用[name]变量（可加hash）来配置出口文件，同时在plugins里需要针对每个入口配置不同的new WebpackPlugin（注意配置对应的chunks）</li></ul></li><li>抽离和压缩css文件 <ul><li>开发环境下可使用style-loader将js中的css代码 通过创建style标签插入到html中</li><li>生产环境下使用MiniCssExtractPlugin.loader，生产css文件通过link方式导入；同时需要在plugins里配置new MiniCssExtractPlugin配置文件名和打包地址，以及在optimization.minimizer里放置压缩的操作</li></ul></li><li>抽离公共代码 <ul><li>通过optimization.splitChuncks来配置如何抽离公共模块，来避免不必要的重复</li><li>chunk（代码块、模块）可来自entry、optimization.splitChunks中设置的模块</li></ul></li><li>懒加载 <ul><li>通过异步方式使用import()导入</li></ul></li><li>jsx <ul><li>通过安装babel-loder @babel/core和**@babel/preset-react**</li></ul></li><li>vue <ul><li>处理vue文件通过vue-loader</li></ul></li><li><strong>module chunk bundle的区别</strong><ul><li>module：一切可以被引用的文件（css、图片、js）都是一个模块；webpack中一切皆模块</li><li>chunk：多模块合并成的一个代码块，如 entry import() splitChunk等，每个chunk包含了一些模块和它们的依赖关系</li><li>bundle：最终的打包文件，包含了多个chunk和一些其他的资源</li></ul></li></ul><h2 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化" aria-hidden="true">#</a> 性能优化</h2><h3 id="优化构建速度" tabindex="-1"><a class="header-anchor" href="#优化构建速度" aria-hidden="true">#</a> 优化构建速度</h3><p>（*可用于生产环境）</p><ul><li><p>优化babel-loader（*）</p><ul><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	<span class="token literal-property property">test</span><span class="token operator">:</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\.js&amp;</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
	<span class="token literal-property property">use</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&#39;babel-loader?cacheDirectory&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//开启缓存</span>
    <span class="token literal-property property">include</span><span class="token operator">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">&#39;src&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment">//明确范围，include/exclude二者选其一</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>IgnorePlugin避免引入无用模块（*）</p><ul><li><p>例如 import moment from &#39;moment&#39;，这样回默认引入所有js代码（包含多语言），代码过大，如何之引入中文？</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 忽略 moment 下的 /locale 目录</span>
<span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>IgnorePlugin</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\.\\/locale</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">moment</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>noParse 避免重复打包（*）</p><ul><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">module</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token comment">// 忽略对react.min.js文件的解析处理</span>
	<span class="token literal-property property">noParse</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token operator">/</span>react\\<span class="token punctuation">.</span>min\\<span class="token punctuation">.</span>js<span class="token operator">/</span>$<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>对比IgnorePlugin与noParse</p><ul><li>IgnorePlugin：直接不引入，代码中没有</li><li>noParse：引入但不打包</li></ul></li><li><p>happyPack 或 thread-loader 开启多进程打包（*）</p></li><li><p>ParallelUglifyPlugin 多进程压缩 JS（*）</p></li><li><p>自动刷新</p><ul><li>整个网页全部刷新、速度较慢、状态丢失</li></ul></li><li><p>热更新</p><ul><li>新代码生效，网页不刷新，状态不丢失</li></ul></li><li><p>DllPlugin</p><ul><li>动态链接库插件</li><li>前端框架如vue React，同一个版本只需构建一次即可，不需每次重新构建</li><li>DllPlugin 打包出dll文件</li><li>DllReferencePlugin 使用dll文件</li></ul></li></ul><h3 id="优化产出代码" tabindex="-1"><a class="header-anchor" href="#优化产出代码" aria-hidden="true">#</a> 优化产出代码</h3><p>原则：体积更小；合理分包，不重复加载；速度更快，内存使用更少</p><ul><li><p>使用生产环境</p><ul><li>自动开启代码压缩</li><li>Vue React等回自动删除调试代码（开发环境的warning）</li><li>自动Tree-Shaking</li></ul></li><li><p>小图片转base64编码</p></li><li><p>bundle加hash</p></li><li><p>使用CDN：在output里设置publicPath，如：‘http://cdn.abc.com&#39;，回修改静态文件（js、css、图片）url的前缀</p></li><li><p>提取公共代码：提取一些公共模块（复用两次以上）、第三方模块（如lodash）</p><ul><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 分割代码块</span>
<span class="token comment">// 分割代码块</span>
    <span class="token literal-property property">splitChunks</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">chunks</span><span class="token operator">:</span> <span class="token string">&quot;all&quot;</span><span class="token punctuation">,</span>
      <span class="token doc-comment comment">/**
             * initial 入口chunk，对于异步导入的文件不处理
                async 异步chunk，只对异步导入的文件处理
                all 全部chunk
             */</span>

      <span class="token comment">// 缓存分组</span>
      <span class="token literal-property property">cacheGroups</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token comment">// 第三方模块</span>
        <span class="token literal-property property">vendor</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;vendor&quot;</span><span class="token punctuation">,</span> <span class="token comment">// chunk 名称</span>
          <span class="token literal-property property">priority</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 权限更高，优先抽离，重要！！！</span>
          <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
          <span class="token literal-property property">minSize</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 大小限制</span>
          <span class="token literal-property property">minChunks</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 最少复用过几次</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>

        <span class="token comment">// 公共的模块</span>
        <span class="token literal-property property">common</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;common&quot;</span><span class="token punctuation">,</span> <span class="token comment">// chunk 名称</span>
          <span class="token literal-property property">priority</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 优先级</span>
          <span class="token literal-property property">minSize</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 公共模块的大小限制</span>
          <span class="token literal-property property">minChunks</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">// 公共模块最少复用过几次</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>懒加载：大文件通过import()</p></li><li><p>IgnorePlugin：避免打包无用模块，可减少体积</p></li><li><p>scope hosting：使用 ModuleConcatenationPlugin 将打包后多个函数里的内容合并到一个函数中</p><ul><li>代码体积更小</li><li>创建函数作用域更少</li><li>代码可读性更好</li><li><img src="`+l+`" alt="image-20230320131122988" style="zoom:50%;float:left;"></li></ul></li></ul><h2 id="esmodule和-commonjs" tabindex="-1"><a class="header-anchor" href="#esmodule和-commonjs" aria-hidden="true">#</a> ESModule和 Commonjs</h2><ul><li>ES6 Module 静态，<strong>编译时引入</strong>，只能放在最外层</li><li>Commonjs 动态，<strong>执行时引入</strong></li><li>只有ES6 Module才能静态分析，实现Tree-Shaking</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> apiList <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./api.js&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>isDev<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 可以动态引入，执行时引入</span>
  apiList <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./api_dev.js&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span> apiList <span class="token keyword">from</span> <span class="token string">&#39;./api.js&#39;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>isDev<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 编译时报错，只能静态引入，放最上层</span>
  <span class="token keyword">import</span> apiList <span class="token keyword">from</span> <span class="token string">&#39;./api_dev.js&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="构建流程概述" tabindex="-1"><a class="header-anchor" href="#构建流程概述" aria-hidden="true">#</a> 构建流程概述</h2><p>Webpack 的构建流程主要可以分为以下几个步骤：</p><ol><li>解析配置文件：Webpack 会读取项目中的配置文件，解析其中的配置信息，例如入口文件、输出路径、loader、插件等。</li><li>解析模块依赖：Webpack 会从入口文件开始递归地解析模块的依赖关系，以构建整个应用程序的<strong>依赖图谱</strong>。在解析过程中，Webpack 会根据配置文件中的loader，将不同类型的模块转换成可以在浏览器中执行的代码。</li><li>生成打包文件：在解析完所有的模块依赖关系之后，Webpack 会根据配置文件中的输出路径，将打包后的代码<strong>生成到指定的目录</strong>下。在此过程中，Webpack 会根据配置文件中的插件，对生成的代码进行一些<strong>额外的处理</strong>，例如压缩、优化等。</li><li>服务端打包：在开发过程中，Webpack 还可以启动一个开发服务器，用于<strong>自动化构建、打包和重新加载</strong>，以加快开发速度。在服务端打包过程中，Webpack 会将所有的资源<strong>打包到内存中</strong>，以提高访问速度和响应能力。</li></ol><h2 id="loader原理" tabindex="-1"><a class="header-anchor" href="#loader原理" aria-hidden="true">#</a> loader原理</h2><p>概念：帮助 webpack 将不同类型的文件转换为 webpack 可识别的模块。</p><p>loader 的执行优级为：<code>pre &gt; normal &gt; inline &gt; post</code> 。</p><p>开发最简单的loader</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">loader1</span><span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hello loader&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> content<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="plugin原理" tabindex="-1"><a class="header-anchor" href="#plugin原理" aria-hidden="true">#</a> Plugin原理</h2><p>概念：通过插件我们可以扩展 webpack，加入自定义的构建行为，使 webpack 可以执行更广泛的任务，拥有更强的构建能力。</p><p>工作原理：webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。</p><p><strong>webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</strong> ——「深入浅出 Webpack」</p><p>站在代码逻辑的角度就是：webpack 在编译代码过程中，会触发一系列 <code>Tapable</code> 钩子事件，插件所做的，就是找到相应的钩子，往上面挂上自己的任务，也就是注册事件，这样，当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行了。</p><p><strong>钩子的本质就是：事件。<strong>为了方便我们直接介入和控制编译过程，webpack 把编译过程中触发的</strong>各类关键事件封装成事件接口</strong>暴露了出来。这些接口被很形象地称做：<code>hooks</code>（钩子）。开发插件，离不开这些钩子。</p><p><code>Tapable</code> 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为：</p><ul><li><code>tap</code>：可以注册同步钩子和异步钩子。</li><li><code>tapAsync</code>：回调方式注册异步钩子。</li><li><code>tapPromise</code>：Promise 方式注册异步钩子。</li></ul><p>最简单的插件：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">TestPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;TestPlugin constructor()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 1. webpack读取配置时，new TestPlugin() ，会执行插件 constructor 方法</span>
  <span class="token comment">// 2. webpack创建 compiler 对象</span>
  <span class="token comment">// 3. 遍历所有插件，调用插件的 apply 方法</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;TestPlugin apply()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> TestPlugin<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="babel" tabindex="-1"><a class="header-anchor" href="#babel" aria-hidden="true">#</a> babel</h2><p>前端必备工具</p><h3 id="基本配置-1" tabindex="-1"><a class="header-anchor" href="#基本配置-1" aria-hidden="true">#</a> 基本配置</h3><ul><li>环境搭建</li><li>.babelrc配置</li><li>presets 和 plugins</li></ul><h3 id="babel-polyfill" tabindex="-1"><a class="header-anchor" href="#babel-polyfill" aria-hidden="true">#</a> babel-polyfill</h3><ul><li>什么时Polyfill</li><li>core-js和 regenerator</li><li>babel-polyfill 即两者的集合，babel7.4之后被<strong>弃用</strong>了，直接推荐使用上面</li><li>按需引入：文件较大 ，需要在babelrc文件里配置按需引入</li><li>存在的问题：污染全局环境</li></ul><h3 id="babel-runtime" tabindex="-1"><a class="header-anchor" href="#babel-runtime" aria-hidden="true">#</a> babel-runtime</h3><p><code>babel-runtime</code> 是一个 JavaScript 运行时库，为使用 Babel 转译的代码提供了一组公共的工具函数和类，它通过一系列的工具函数和类，使转译后的代码更加精简、高效</p><p><code>babel-polyfill</code> 会直接在全局环境中注入 polyfill，以使其能够在目标环境中正常运行。而 <code>babel-runtime</code> 则是通过将其作为模块引入到需要使用的地方，以减少冗余代码。同时解决了babel-polyfill变量污染的问题。</p><h2 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h2><h3 id="前端为什么要做打包构建" tabindex="-1"><a class="header-anchor" href="#前端为什么要做打包构建" aria-hidden="true">#</a> 前端为什么要做打包构建？</h3><p>代码层</p><ul><li>文件压缩和资源管理：压缩html css js 图片等资源与合并，进行统一管理，加载更快</li><li>编译高级语言或语法：ts es6 模块化 scss等</li><li>兼容性和错误检查：polyfill postcss eslint等，保证在不同的浏览器和设备上都能够正常运行。</li></ul><p>流程层</p><ul><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ul><h3 id="loader和plugin的区别" tabindex="-1"><a class="header-anchor" href="#loader和plugin的区别" aria-hidden="true">#</a> loader和plugin的区别</h3><ul><li>loder 模块转换器，如less -&gt; css</li><li>plugin 扩展插件，如HtmlWebpackPlugin</li></ul><h3 id="babel和webpack的区别" tabindex="-1"><a class="header-anchor" href="#babel和webpack的区别" aria-hidden="true">#</a> babel和webpack的区别</h3><ul><li>babel：js的新语法编译工具，只关心语法，不关心API和模块化</li><li>webpack：打包构建工具，是多个loader plugin的集合</li></ul><h3 id="如何产出一个lib" tabindex="-1"><a class="header-anchor" href="#如何产出一个lib" aria-hidden="true">#</a> 如何产出一个lib</h3><img src="`+i+'" alt="image-20230320153854122" style="zoom:50%;float:left;"><h3 id="webpack如何实现懒加载" tabindex="-1"><a class="header-anchor" href="#webpack如何实现懒加载" aria-hidden="true">#</a> webpack如何实现懒加载</h3><ul><li>import() ，结合Vue React 异步组件；结合Vue-router React-router异步加载路由</li></ul><h3 id="为何proxy不能被polyfill" tabindex="-1"><a class="header-anchor" href="#为何proxy不能被polyfill" aria-hidden="true">#</a> 为何proxy不能被Polyfill</h3><ul><li>如class可以用function模拟</li><li>如Promise可以用callback模拟</li><li>但Proxy的<strong>功能</strong>无法是使用Object.defineProperty模拟</li></ul>',58),o=[t];function c(r,u){return a(),s("div",null,o)}const k=n(p,[["render",c],["__file","webpack.html.vue"]]);export{k as default};
