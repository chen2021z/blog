import{_ as t,r as p,o,c as l,a as n,b as a,e as i,d as s}from"./app-3bf9788e.js";const c="/blog/image-20230318160356272.png",u="/blog/image-20230318200206827.png",r={},d=s('<h1 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3" aria-hidden="true">#</a> Vue3</h1><h2 id="vue3比vue2有什么优势" tabindex="-1"><a class="header-anchor" href="#vue3比vue2有什么优势" aria-hidden="true">#</a> Vue3比Vue2有什么优势？</h2><ol><li>性能更好</li><li>体积更小</li><li>更好的ts支持</li><li>更好的代码组织</li><li>更好的逻辑抽离</li><li>更多新功能</li></ol><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><h3 id="options-api生命周期" tabindex="-1"><a class="header-anchor" href="#options-api生命周期" aria-hidden="true">#</a> options API生命周期</h3><ul><li>beboreDestroy改为beforeUnmount</li><li>destoryed改为unmounted</li><li>其他沿用Vue2的生命周期</li></ul><h3 id="composition-api生命周期" tabindex="-1"><a class="header-anchor" href="#composition-api生命周期" aria-hidden="true">#</a> composition API生命周期</h3><ul><li>setup相当于beforeCreate和created</li><li>名字前加on，如onBeforeMount，onMounted</li></ul><h2 id="compositionapi带来了什么" tabindex="-1"><a class="header-anchor" href="#compositionapi带来了什么" aria-hidden="true">#</a> CompositionAPI带来了什么？</h2><ul><li>更好的代码组织</li><li>更好的逻辑复用</li><li>更好的类型推导</li></ul><h3 id="如何选择" tabindex="-1"><a class="header-anchor" href="#如何选择" aria-hidden="true">#</a> 如何选择？</h3><ul><li><p>不建议共用，会引起混乱</p></li><li><p>小型项目、业务简单，optionsAPI</p></li><li><p>中大型项目、逻辑复杂，用CompositionAPI</p></li></ul><h2 id="理解ref-toref-和-torefs" tabindex="-1"><a class="header-anchor" href="#理解ref-toref-和-torefs" aria-hidden="true">#</a> 理解ref toRef 和 toRefs</h2><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> ref</h3><ul><li>生成值类型的响应式数据</li><li>可用于模板和reactive里，都不需要.value</li><li>通过.value修改值</li></ul><h3 id="toref" tabindex="-1"><a class="header-anchor" href="#toref" aria-hidden="true">#</a> toRef</h3><p>基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。</p><ul><li>toRef如果用于普通对象则产出的结果不具有响应式</li><li>创建一个ref，具有响应式</li><li>两者保持引用关系</li></ul><h3 id="torefs" tabindex="-1"><a class="header-anchor" href="#torefs" aria-hidden="true">#</a> toRefs</h3>',19),k={href:"https://cn.vuejs.org/api/reactivity-utilities.html#toref",target:"_blank",rel:"noopener noreferrer"},v=n("code",null,"toRef()",-1),m=s(`<ul><li><p>当从组合式函数中返回响应式对象时，<code>toRefs</code> 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性，如果是reactive对象 直接将其结构则会失去响应性</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// ...基于状态的操作逻辑</span>

  <span class="token comment">// 在返回时都转为 ref</span>
  <span class="token keyword">return</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 可以解构而不会失去响应性</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="最佳使用方式" tabindex="-1"><a class="header-anchor" href="#最佳使用方式" aria-hidden="true">#</a> 最佳使用方式</h3><ul><li><p>用reactive做对象的响应式，用ref做值类型的响应式</p></li><li><p>setup中返回toRefs(state)，或者toRef(state, &quot;xxx&quot;)</p></li><li><p>ref变量命名使用xxxRef</p></li><li><p>组合式函数返回响应式对象，使用toRefs</p></li></ul><h3 id="进阶理解" tabindex="-1"><a class="header-anchor" href="#进阶理解" aria-hidden="true">#</a> 进阶理解</h3><ul><li><p>为什么需要ref？</p><ul><li>返回值类型，会丢失响应式</li><li>如在setup、computed、组合式函数里都有可能返回值类型</li><li>因为有需求，Vue如果不定义ref，用户将自造ref，反而混乱</li></ul></li><li><p>为什么需要.vlaue?</p><ul><li>在Vue3中，ref是用来对基本类型数据进行响应式处理的一个API。与Vue2中的data属性不同，ref并不是直接返回被包装的数据本身，<strong>而是一个包含value属性的对象</strong>，需要通过访问<code>value</code>属性才能获取被包装的数据。</li><li>这是因为在Vue3中，为了提高响应式系统的性能和可维护性，采用了一种新的内部实现机制——Proxy，而<strong>Proxy只能拦截对象的读写操作</strong>，无法直接拦截基本类型数据的读写操作。因此，在Vue3中，<strong>为了实现对基本类型数据的响应式处理</strong>，需要将基本类型数据<strong>包装成一个对象</strong>，并提供一个访问这个对象的属性的方法，这就是ref所做的事情。</li><li>这样做的好处是能够利用Proxy机制对对象的读写进行拦截，提高响应式系统的性能和可维护性。</li></ul></li><li><p>为什么需要toRef toRefs?</p><ul><li><p>初衷：在不丢失响应式地情况下，把对象数据分解、扩散</p></li><li><p>前提：针对响应式对象（reactive），而非普通对象</p></li><li><p>注意：<strong>不创造响应式，而是延续响应式</strong></p></li></ul></li></ul><h2 id="vue3升级了哪些功能" tabindex="-1"><a class="header-anchor" href="#vue3升级了哪些功能" aria-hidden="true">#</a> Vue3升级了哪些功能？</h2><ol><li><p>createApp，返回应用实例</p></li><li><p>emits属性，接收父组件的自定义事件</p></li><li><p>Fragment</p></li><li><p>v-model</p><ol><li>prop和事件默认名称改为modelValue和：update:modelValue</li><li>移除.sync修饰符和model选项，可在v-model上添加参数代替</li><li>支持多个v-model和自定义v-model修饰符</li></ol></li><li><p>key</p><ol><li><p>不再建议在 <code>v-if</code>/<code>v-else</code>/<code>v-else-if</code> 的分支中继续使用 <code>key</code> attribute，因为没有为条件分支提供 <code>key</code> 时，也会自动生成唯一的 <code>key</code></p></li><li><p>当使用 <code>&lt;template v-for&gt;</code> 时如果存在使用 <code>v-if</code> 的子节点，则 <code>key</code> 应改为设置在 <code>&lt;template&gt;</code> 标签上。</p></li><li><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token comment">&lt;!-- Vue 2.x --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.isVisible<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-else</span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- Vue 3.x --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item in list<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.id<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item.isVisible<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-else</span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p>v-if与v-for优先级</p><ol><li>在3中<code>v-if</code> 会拥有比 <code>v-for</code> 更高的优先级</li></ol></li><li><p>生命周期</p></li><li><p>异步组件的写法</p><ol><li>新的 <code>defineAsyncComponent</code> 助手方法，用于显式地定义异步组件</li><li><code>component</code> 选项被重命名为 <code>loader</code></li><li><img src="`+c+`" alt="image-20230318160356272"></li></ol></li><li><p>新增组件：Teleport、Suspense</p></li><li><p>CompositionAPI</p><ol><li>抽离逻辑函数到一个函数</li><li>函数命名约定为useXxx格式</li></ol></li></ol><h2 id="vue3响应式" tabindex="-1"><a class="header-anchor" href="#vue3响应式" aria-hidden="true">#</a> Vue3响应式</h2><h3 id="reflect作用与目的" tabindex="-1"><a class="header-anchor" href="#reflect作用与目的" aria-hidden="true">#</a> Reflect作用与目的</h3><ul><li><p>和proxy能力一一对应</p></li><li><p>规范化、标准化、函数式</p></li><li><p>代替Object上的工具函数</p></li><li><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">}</span>

<span class="token string">&#39;a&#39;</span> <span class="token keyword">in</span> obj  <span class="token comment">//true</span>
Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span> <span class="token comment">//true</span>

<span class="token keyword">delete</span> obj<span class="token punctuation">.</span>b
Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="优化点" tabindex="-1"><a class="header-anchor" href="#优化点" aria-hidden="true">#</a> 优化点</h3><ul><li>深度惰性监听，性能更好</li><li>可监听新增、删除属性</li><li>可监听数组变化</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><ul><li>proxy能规避Object.definproperty的问题</li><li>Proxy无法兼容所有浏览器，无法polyfill</li></ul><h3 id="怎么实现响应式-面试回答" tabindex="-1"><a class="header-anchor" href="#怎么实现响应式-面试回答" aria-hidden="true">#</a> 怎么实现响应式（面试回答）</h3><p>在 Vue3 中，实现响应式的方式与 Vue2 有所不同，主要是通过新的 <code>reactive</code> 和 <code>ref</code> 函数来实现。<code>reactive</code> 函数将一个普通的 JavaScript 对象转换成响应式对象，而 <code>ref</code> 函数则用于将一个基本类型的值转换成响应式对象。</p><ol><li><code>reactive</code> 的实现</li></ol><p><code>reactive</code> 函数的实现依赖于 ES6 中的 <code>Proxy</code> 对象。在 Vue3 中，使用 <code>Proxy</code> 对象代理目标对象，并在代理对象上定义 <code>get</code> 和 <code>set</code> 方法来实现对目标对象属性的访问和修改的拦截。在 <code>get</code> 和 <code>set</code> 方法中，通过调用 <code>track</code> 和 <code>trigger</code> 函数来实现对属性的依赖追踪和更新视图通知。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 追踪依赖</span>
      <span class="token function">track</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> oldValue <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldValue <span class="token operator">!==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 触发更新通知</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><code>ref</code> 的实现</li></ol><p><code>ref</code> 函数的实现依赖于 JavaScript 中的原始类型和对象的特点。在 Vue3 中，使用 JavaScript 中的原始类型和对象来代表响应式对象，并使用 <code>Proxy</code> 对象代理这些原始类型和对象，从而实现对它们的访问和修改的拦截。</p><p>下面是 <code>ref</code> 函数的简化实现：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> refObj <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">,</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">track</span><span class="token punctuation">(</span>refObj<span class="token punctuation">,</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> refObj<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">!==</span> refObj<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        refObj<span class="token punctuation">.</span>value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token function">trigger</span><span class="token punctuation">(</span>refObj<span class="token punctuation">,</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>refObj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> target<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">&#39;value&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="watch和watcheffect的区别" tabindex="-1"><a class="header-anchor" href="#watch和watcheffect的区别" aria-hidden="true">#</a> watch和watchEffect的区别</h2><ul><li>两者都可以监听属性变化</li><li>watchEffect会根据其中的属性，自动监听其变化</li><li>watchEffect初始化时会监听一次（收集要监听的数据）</li></ul><h2 id="setup中如何获取组件实例" tabindex="-1"><a class="header-anchor" href="#setup中如何获取组件实例" aria-hidden="true">#</a> setup中如何获取组件实例</h2><ul><li>setup和其他CompositionAPI中没有this</li><li>可通过getCurrentInstance获取当前实例</li><li>若使用OptionsAPI可照常使用this</li></ul><h3 id="vue3为何比vue2快" tabindex="-1"><a class="header-anchor" href="#vue3为何比vue2快" aria-hidden="true">#</a> Vue3为何比Vue2快</h3><ul><li>Proxy响应式</li><li>PatchFlag <ul><li>模板编译时，动态节点做标记</li><li>标记分为不同的类型，如 text props class等</li><li>目的： diff算法时，可以区分静态节点，以及不同类型的动态节点，优化diff算法</li><li><img src="`+u+'" alt="image-20230318200206827" style="zoom:67%;float:left;"></li></ul></li><li>hoistStatic <ul><li>将静态节点的定义 提升到父作用域，缓存起来</li><li>多个相邻的静态节点，会被合并起来</li><li>典型的拿空间换时间</li></ul></li><li>cacheHandler <ul><li>缓存事件</li></ul></li><li>SSR优化 <ul><li>静态节点直接输出，绕过vdom</li><li>动态节点，还是需要动态渲染</li></ul></li><li>tree-shaking <ul><li>编译时，根据不同的情况（用了哪些指令、功能），引入不同的API</li></ul></li></ul><h2 id="vite" tabindex="-1"><a class="header-anchor" href="#vite" aria-hidden="true">#</a> Vite</h2><h3 id="为什么启动快" tabindex="-1"><a class="header-anchor" href="#为什么启动快" aria-hidden="true">#</a> 为什么启动快</h3><ul><li>开发环境使用ES6 Module，无需打包---非常快</li><li>生产环境使用rollup，不会快很多</li></ul>',32);function h(f,b){const e=p("ExternalLinkIcon");return o(),l("div",null,[d,n("p",null,[a("将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 "),n("a",k,[v,i(e)]),a(" 创建的。")]),m])}const y=t(r,[["render",h],["__file","Vue3.html.vue"]]);export{y as default};
