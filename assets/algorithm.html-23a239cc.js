import{_ as l,o as i,c as a,e}from"./app-0ccd9946.js";const t="/blog/image-20230322222643691.png",r="/blog/image-20230323141710124.png",o="/blog/image-20230323142239710.png",h="/blog/image-20230323142358470.png",s="/blog/image-20230323142533818.png",n="/blog/image-20230323143051327.png",d="/blog/image-20230323152525393.png",c="/blog/image-20230323152626422.png",g={},m=e('<h2 id="链表和数组-那个实现队列更快" tabindex="-1"><a class="header-anchor" href="#链表和数组-那个实现队列更快" aria-hidden="true">#</a> 链表和数组，那个实现队列更快？</h2><ul><li>数组是<strong>连续</strong>存储，push很快，shift很慢</li><li>链表是<strong>非连续</strong>存储，add和delete都很快（查找很慢）</li><li>结论：链表实现队列更快</li></ul><h2 id="链表实现队列" tabindex="-1"><a class="header-anchor" href="#链表实现队列" aria-hidden="true">#</a> 链表实现队列</h2><ul><li>单向链表，但要同时记录tail和head</li><li>要从tail入队，从head出队，否则出队时tail不好定位</li><li>length要实时记录，不可遍历链表获取</li></ul><h2 id="二叉搜索树" tabindex="-1"><a class="header-anchor" href="#二叉搜索树" aria-hidden="true">#</a> 二叉搜索树</h2><ul><li>数组：查找快，增删慢</li><li>链表：查找慢，增删快</li><li>二叉搜索树BST：查找快，增删快 ---木桶效应</li></ul><h2 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树" aria-hidden="true">#</a> 平衡二叉树</h2><ul><li>BST如果不平衡，就成了链表了</li><li>所以要尽量平衡：平衡二叉搜索树 BBST</li><li>BBST 增删查，时间复杂度都是 logn，即树的高度，n是节点数</li></ul><h2 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树" aria-hidden="true">#</a> 红黑树</h2><ul><li>一种自平衡二叉树</li><li>分为红、黑两种颜色，通过颜色转换来维持树的平衡</li><li>相对于普通平衡二叉树，它维持平衡的的效率更高</li></ul><h2 id="b树" tabindex="-1"><a class="header-anchor" href="#b树" aria-hidden="true">#</a> B树</h2><ul><li>物理上是多叉树，但逻辑上是二叉树</li><li>一般用于高效IO，关系型数据库常用B树来组织数据</li><li><img src="'+t+'" alt="image-20230322222643691" style="zoom:50%;float:left;"></li></ul><h2 id="堆栈模型" tabindex="-1"><a class="header-anchor" href="#堆栈模型" aria-hidden="true">#</a> 堆栈模型</h2><ul><li>JS代码执行时，值类型变量，存储在栈；引用类型，存储在堆</li><li><img src="'+r+'" alt="image-20230323141710124" style="zoom:50%;float:left;"></li></ul><h3 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h3><ul><li>完全二叉树</li><li><img src="'+o+'" alt="image-20230323142239710" style="zoom:50%;float:left;"></li><li>最大堆：父节点 &gt;= 子节点</li><li>最小堆：父节点 &lt;= 子节点</li><li><img src="'+h+'" alt="image-20230323142358470" style="zoom:50%;float:left;"></li><li><img src="'+s+'" alt="image-20230323142533818" style="zoom:50%;float:left;"></li><li><img src="'+n+'" alt="image-20230323143051327" style="zoom:50%;float:left;"></li><li>使用场景： <ul><li>堆栈模型</li><li>堆的数据，都是在栈中引用，不需要从root遍历</li><li>堆恰好的数组形式，根据栈的地址，可用O(1)找到目标</li></ul></li></ul><h2 id="动态规划-青蛙跳台阶" tabindex="-1"><a class="header-anchor" href="#动态规划-青蛙跳台阶" aria-hidden="true">#</a> 动态规划-青蛙跳台阶</h2><ul><li>要跳一级台阶，1种方式 f(1) = 1</li><li>要跳两级台阶，2种方式 f(2) = 2</li><li>要跳n级台阶，方式和：f(n) = f(n -1) + f(n -2)</li></ul><h2 id="移动0到数组末尾" tabindex="-1"><a class="header-anchor" href="#移动0到数组末尾" aria-hidden="true">#</a> 移动0到数组末尾</h2><ul><li><p>如 [1,0,3,4,0,5]，输出[1,3,4,5,0,0]</p></li><li><p>只移动0，其他顺序不变</p></li><li><p>必须再原数组操作</p></li><li><img src="'+d+'" alt="image-20230323152525393" style="zoom:50%;float:left;"></li><li><img src="'+c+'" alt="image-20230323152626422" style="zoom:50%;float:left;"></li></ul>',20),f=[m];function u(_,p){return i(),a("div",null,f)}const x=l(g,[["render",u],["__file","algorithm.html.vue"]]);export{x as default};
