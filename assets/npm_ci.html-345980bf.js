import{_ as a,r as c,o as i,c as d,a as e,b as o,d as l,e as s}from"./app-84d7f4b0.js";const t={},p=e("h1",{id:"生产环境中使用-npm-ci-代替-npm-i",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#生产环境中使用-npm-ci-代替-npm-i","aria-hidden":"true"},"#"),o(" 生产环境中使用 npm ci 代替 npm i")],-1),r=e("p",null,[o("乍一眼看 "),e("code",null,"npm ci"),o("，CI，恩，看这名字就很适合放在持续集成中。事实也是如此，它更快，更严格，也更适合于放在 CI 中，至于为什么这么说，将会在以下分别做介绍。")],-1),h=e("code",null,"npm ci",-1),m={href:"https://github.com/npm/libcipm",target:"_blank",rel:"noopener noreferrer"},k=e("code",null,"npm install",-1),g=s('<p>直接从官方文档看 <code>npm ci</code> 与 <code>npm i</code> 的不同之处吧</p><blockquote><p>In short, the main differences between using npm install and npm ci are:</p><ul><li>The project must have an existing package-lock.json or npm-shrinkwrap.json.</li><li>If dependencies in the package lock do not match those in package.json, npm ci will exit with an error, instead of updating the package lock.</li><li>npm ci can only install entire projects at a time: individual dependencies cannot be added with this command.</li><li>If a node_modules is already present, it will be automatically removed before npm ci begins its install.</li><li>It will never write to package.json or any of the package-locks: installs are essentially frozen.</li></ul></blockquote><p>我将基于官方文档做适当扩展</p><h2 id="package-lock-json-必须存在" tabindex="-1"><a class="header-anchor" href="#package-lock-json-必须存在" aria-hidden="true">#</a> package-lock.json 必须存在</h2><p><code>package-lock.json</code> 在 <code>npm ci</code> 时是必须存在的，否则将会报错，阻塞住 CI pipeline 的进一步执行。</p><p><code>package-lock.json</code> 用于锁住 package 的版本号，避免在生产环境中因版本导致的构建错误或者运行时错误，对于前端工程化也意义非凡。<code>npm ci</code> 时 <code>package-lock.json</code> 必须存在也避免了此类问题的产生，它对项目的安全性有所提高。</p><h2 id="package-json-与-package-lock-json-不匹配问题" tabindex="-1"><a class="header-anchor" href="#package-json-与-package-lock-json-不匹配问题" aria-hidden="true">#</a> package.json 与 package-lock.json 不匹配问题</h2><p>有可能您会有疑惑了，它们怎么会不匹配呢？在正常情况下肯定不会出现这种问题。</p><ol><li><strong>手动改动</strong> <code>package.json</code> 中某个 package 的版本号</li><li><strong>没有</strong> 再次 <code>npm install</code></li><li><code>git push</code> 触发了 CI</li></ol><p>在我工作经历中，遇到过手动改写 <code>package.json</code> 中版本号，却未同步到 <code>package-lock.json</code> 的事件。</p><p>而使用 <code>npm ci</code> 将会保证其安全性，但两者不匹配时，直接抛出异常。这给我们两个教训</p><ol><li>不要手动改写版本号</li><li>在 CI 中使用 <code>npm ci</code> 保证安全性</li></ol><h2 id="自动删除-node-modules" tabindex="-1"><a class="header-anchor" href="#自动删除-node-modules" aria-hidden="true">#</a> 自动删除 node_modules</h2><p>当 <code>npm ci</code> 时，如果 node_modules 存在，则自动删除它，这是为了保证一个干净的 node_modules 环境，避免遗留旧版本库的副作用。</p><p>但由于在 CI 中往往是无状态的：触发构建时，将会在一个临时目录中拉取代码，此时node_modules 也不会存在。</p><h2 id="不能单独装包" tabindex="-1"><a class="header-anchor" href="#不能单独装包" aria-hidden="true">#</a> 不能单独装包</h2><p>这一条很容易解释，它适用于持续集成环境中，无法单独装包，例如无法仅仅安装 <code>lodash</code>。</p>',17);function _(u,f){const n=c("ExternalLinkIcon");return i(),d("div",null,[p,r,e("p",null,[h,o(" 基于一个独立的库 "),e("a",m,[o("libcipm"),l(n)]),o(" 安装依赖，而它拥有和 "),k,o(" 兼容的 API。当它安装依赖时，默认是缓存优先的，它会充分利用缓存，从而加速装包。")]),g])}const b=a(t,[["render",_],["__file","npm_ci.html.vue"]]);export{b as default};
