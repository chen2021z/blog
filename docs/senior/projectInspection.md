---
title:  项目考察
date: 2023/04/02
tags:
 - 项目考察
categories:
 - 面试题  
---

### H5页面如何进行首屏优化？ 

1. 路由懒加载
   + 适用于SPA（不适用MPA）
   + 路由拆分，优先保证首页加载
2. 服务端渲染SSR
   + 传统SPA，渲染页面复杂,SSR 渲染简单，所以性能好
   + 如果时纯H5页面，SSR是性能优化的终极方案
   + SSR是一项‘古老’的技术，web1.0时：php asp jsp等；现代技术框架nuxt.js 和Next.js
3. APP预取
   + 如果H5在 APP webView 中展示，可用APP预取
   + 用户访问列表页，APP预加载文章首屏内容
   + 用户进入H5 页，直接从APP中获取内容，瞬间展示首屏
4. 分页
   + 针对列表页
   + 默认只展示第一页内容，上滑加载更多
5. 图片懒加载 lazyLoad
   + 针对详情页
   + 默认只展示文本内容，然后触发图片懒加载
   + 注意：提前设置图片尺寸，尽量只重绘不重排
6. Hybrid
   + 提前将HTML CSS JS 下载到App内部
   + 在App WebView中使用 file://协议记载页面文件
   + 再用Ajax获取内容并展示（可以结合App预取）

### 后端一次性返回10w条数据，你该如何渲染？

设计不合理，技术方案本身就不合理，先和面试官沟通

一定要处理：问题是：js没问题，一次性渲染到DOM会非常卡顿

1. 自定义中间层，获取并拆分这10w条数据，前端对接node中间层，而不是服务端；但成本比较高
2. 虚拟列表：只渲染可视区预的DOM，其他区域不限制，只用div撑起高度 ，随着浏览器滚动去创建和销毁DOM；但实现起来非常复杂，可借用第三方库，如Vue-virtual-scroll-list

### 前端常见的设计模式有哪些？并说明使用场景

设计原则：开放封闭原则，对扩展开放，对修改封闭

1. 工厂模式

   用一个工厂函数，来创建实例，隐藏 new；如jQuery 的 $函数，React的 createElement函数

2. 单例模式

   全局唯一的实例（无法产生第二个），如 Vuex Redux的store

   <img src="/image-20230402211711176.png" alt="image-20230402211711176"  />

   js是单线程的，创建单例很简单，但java是支持多线程的，多线程共享进程内存，创建单例需要考虑锁死线程

3. 代理模式

   使用者不能直接访问对象，而是访问一个代理层，在代理层可以监听get set 做很多事情，如Proxy实现Vue3的响应式

4. 观察者模式

   一个主题，一个观察者，主题变化之后触发观察者执行

   ```js
   btn.addEventListener('click', () => {...})
   ```

5. 发布订阅

   ```js
   event.on('event-key', () => {
   	//事件1
   })
   event.on('event-key', () => {
   	//事件2
   })
   
   //触发执行
   event.emit('event-key')
   ```

6. 装饰器模式

   原功能不变，增加一些新功能（AOP 面向切面编程），ES和TypeScript的Decorator语法，类装饰器，方法装饰器

### 观察者模式和发布订阅模式的区别

观察者模式和发布订阅模式都是用于在不同对象之间传递信息的设计模式，它们的主要区别在于它们的交互方式和关注点。

观察者模式是一种对象之间的一对多的依赖关系，其中一个对象（主题）通过将其状态的变化通知给其他对象（观察者）来实现这种依赖关系。在观察者模式中，主题知道哪些观察者对其进行了关注，并在状态发生变化时通知它们。观察者模式中的观察者没有彼此之间的联系，它们只与主题进行交互。

发布订阅模式也是一种对象之间的一对多的依赖关系，其中发布者（或主题）将消息发送到一个消息代理（或中心），然后订阅者（或观察者）从消息代理那里接收消息。在发布订阅模式中，订阅者没有直接联系，而是通过消息代理进行交互。

因此，观察者模式强调的是主题和观察者之间的直接交互，而发布订阅模式强调的是发布者和订阅者之间的间接交互。此外，观察者模式中的观察者是知道主题的存在和状态的，而发布订阅模式中的订阅者只知道消息代理的存在，而不知道发布者的存在。

![image-20230402213710023](/image-20230402213710023.png)



### 在实际工作中，你做过哪些Vue优化？

1. v-if v-show:

   v-if 彻底销毁组件；v-show使用css隐藏组件；大部分适合v-if更好，不要过渡优化

2. 使用computed缓存

   例如，可以对消息列表去缓存未读消息

3. keep-alive缓存

   频发切换的组件如tabs

4. 异步组件 asyncComponent

   针对体积较大的组件，如编辑器、复杂表格表单等；进行拆包，需要时异步加载，不需要时不加载；可减少主包体积，首页加载会更快

5. 路由懒加载

6. 服务端渲染SSR：可使用Nuxt.js

### 使用Vue遇到过哪些坑？

1. 内存泄漏

   全局变量，全局事件，全局定时器以及自定义事件没有及时销毁

2. Vue2响应式的缺陷

   data新增属性用$set，删除用$delete，直接修改数组数据arr[index]=value

3. 路由切换时scroll 到顶部

   SPA的通病，列表页点击进入详情页，再返回列表页（此时组件重新渲染）就scroll到顶部

   解决方案：缓存scrollTop值，当返回列表页时，渲染组件执行scrollTop

   终极方案：MPA + App WebView

### 如何统一监听Vue组件报错？

1. window.onerror = function(){}

   全局监听所有js错误，但它是js级别的，识别不了Vue组件信息，用于捕捉一些vue监听不到的错误 （比如异步报错）

2. errorCaptured 生命周期

   监听所有下级组件的错误，如果return false会停止向上传播 ；用于监听一些重要的、有风险的错误

3. errorHandler 配置（main.js中）

   Vue全局错误监听，所有组件错误都会汇总到这里，但errorCaptured 返回false，则不会传播到这里；与window.onerror互斥

   ```js
   app.config.errorHandler = (err, vm, info) => {...}
   ```

4. 异步错误

   Vue监听不了异步报错，需要使用window.onerror

### 如果一个H5很慢，你该如何排查性能问题？

1. 先沟通，是哪慢？加载慢？操作慢？问具体的现象是什么？

2. 前端的性能指标？

   First Paint(FP)

   First Contentful Paint(FCP) 开始有内容了

   First Meaningful Paint(FMP) 首次有意义的渲染，已弃用（改用LCP），因为没有检测标准

   DomContentLoaded(DCL) 页面DOM加载完成

   Largest Contentful Paint 页面最大的内容渲染完毕

   Load 所有资源都加载完毕

   通过devTools 的performance和network 可以查看上述性能指标，分析是加载很慢还是渲染很慢

3. 工具lighthouse

   流行的第三方性能测评工具，支持移动和pc

   帮助识别问题，哪慢？加载慢？渲染慢？

   如果加载慢（如github）: 优化服务端硬件配置，使用CDN；路由懒加载，大组件异步加载，以减少主包体积；优化http缓存策略

   如果网页渲染：优化服务端接口（请求数据慢），继续优化前端组件内部逻辑；服务端SSR

4. 性能优化是一个循序渐进的过程，不像改bug，需要持续跟进统计结果，可使用第三方统计，如阿里云ARMS

###  工作中遇到了什么项目难度，如何解决的？

答案模板：

描述问题：背景 + 现象 + 造成的影响

问题如何被解决：分析 + 解决

自己的成长：学习到了什么 + 以后如何避免 